---
name: systematic-debugging
description: Use when バグ、テスト失敗、予期しない挙動に遭遇したら、修正案を出す前に使う
---

# システマティック・デバッグ

## 概要

行き当たりばったりの修正は時間を浪費し、新しいバグを生む。急場しのぎのパッチは根本原因を隠す。

**中核原則:** 修正を試みる前に必ず根本原因を見つける。症状への修正は失敗である。

**このプロセスの文字を破ることは、デバッグ精神を破ることと同義。**

## 鉄則

```
ROOT CAUSE INVESTIGATION FIRST — 修正はその後
```

Phase 1 を完了していないなら、修正を提案してはいけない。

## 使うべき場面

あらゆる技術的問題に使用:
- テスト失敗
- 本番バグ
- 予期しない挙動
- パフォーマンス問題
- ビルド失敗
- 統合不具合

**特に使うべき場面:**
- 時間的プレッシャーがあるとき（緊急時ほど当て推量に走りやすい）
- 「1つだけの簡単修正」が明白に見えるとき
- すでに複数の修正を試したとき
- 前の修正が効かなかったとき
- 問題を十分理解できていないとき

**スキップしてはいけない場面:**
- 簡単そうに見える問題（簡単なバグにも根本原因がある）
- 急いでいるとき（焦りは手戻りを保証する）
- 今すぐ直せと迫られているとき（系統立てた方が早い）

## 4つのフェーズ

次のフェーズへ進む前に、各フェーズを必ず完了すること。

### Phase 1: 根本原因の調査

**どんな修正よりも先に:**

1. **エラーメッセージを丁寧に読む**
   - エラーや警告を読み飛ばさない
   - そこに解が書かれていることが多い
   - スタックトレースを最後まで読む
   - 行番号、ファイルパス、エラーコードを控える

2. **再現性を確保する**
   - 確実に再現できるか？
   - 正確な手順は何か？
   - 毎回起きるか？
   - 再現できないなら → データを集める。推測しない。

3. **直近の変更を確認する**
   - 何が変わって起きた可能性があるか？
   - Git diff、最近のコミット
   - 新しい依存関係や設定変更
   - 環境差分

4. **複数コンポーネントのシステムで証拠を集める**

   **システムが複数コンポーネント（CI → build → signing、API → service → database）を持つとき:**

   **修正提案の前に診断用の計測を入れる:**
   ```
   各コンポーネント境界ごとに:
     - 入力データをログ
     - 出力データをログ
     - 環境/設定の伝播を確認
     - 各層の状態を確認

   1回実行して「どこで壊れるか」の証拠を集める
   その証拠を分析して失敗コンポーネントを特定する
   そのコンポーネントを重点的に調査する
   ```

   **例（多層システム）:**
   ```bash
   # Layer 1: Workflow
   echo "=== Secrets available in workflow: ==="
   echo "IDENTITY: ${IDENTITY:+SET}${IDENTITY:-UNSET}"

   # Layer 2: Build script
   echo "=== Env vars in build script: ==="
   env | grep IDENTITY || echo "IDENTITY not in environment"

   # Layer 3: Signing script
   echo "=== Keychain state: ==="
   security list-keychains
   security find-identity -v

   # Layer 4: Actual signing
   codesign --sign "$IDENTITY" --verbose=4 "$APP"
   ```

   **これで分かること:** どの層で失敗するか（secrets → workflow ✓, workflow → build ✗）

5. **データフローを追跡する**

   **エラーが深いコールスタックにあるとき:**

   このディレクトリの `root-cause-tracing.md` を参照し、完全な逆向きトレース手法を使う。

   **簡易版:**
   - 悪い値はどこで生成されたか？
   - どの呼び出し元がその悪い値を渡したか？
   - ソースまで遡っていく
   - 症状ではなく発生源で直す

### Phase 2: パターン分析

**修正前にパターンを見つける:**

1. **動いている例を探す**
   - 同じコードベース内の類似箇所を探す
   - 壊れているものに似た「動くもの」は何か？

2. **参照実装と比較する**
   - パターンを実装するなら参照実装を最後まで読む
   - ざっと読まない。全行読む。
   - パターンを完全に理解してから適用する

3. **差分を特定する**
   - 動くものと壊れているものの違いは何か？
   - どんな小さな違いでもすべて挙げる
   - 「それは関係ない」と決めつけない

4. **依存関係を理解する**
   - 何に依存しているか？
   - どんな設定、環境が必要か？
   - どんな前提があるか？

### Phase 3: 仮説と検証

**科学的方法:**

1. **単一の仮説を立てる**
   - 明確に言う: 「原因はXだと思う。理由はY」
   - 書き出す
   - 具体的に、曖昧にしない

2. **最小限でテストする**
   - 仮説を検証するための最小の変更をする
   - 1変数ずつ
   - 同時に複数箇所を直さない

3. **続ける前に検証する**
   - うまくいった？ はい → Phase 4
   - うまくいかない？ 新しい仮説を立てる
   - さらに修正を積み上げない

4. **分からないとき**
   - 「Xが分からない」と言う
   - 知ったふりをしない
   - 助けを求める
   - さらに調べる

### Phase 4: 実装

**症状ではなく根本原因を修正する:**

1. **失敗するテストケースを作る**
   - 最小の再現
   - 可能なら自動テスト
   - フレームワークがないならワンオフのテストスクリプト
   - 修正前に必須
   - 適切な失敗テストの書き方は `superpowers:test-driven-development` を使う

2. **単一の修正を実装する**
   - 特定した根本原因を修正
   - 1回に1変更
   - 「ついでに」改善しない
   - リファクタリングを束ねない

3. **修正を検証する**
   - テストは通るか？
   - 他のテストは壊れていないか？
   - 問題は本当に解決したか？

4. **修正が効かないとき**
   - STOP
   - 回数を数える: 何回試したか？
   - 3回未満なら: Phase 1 に戻って再分析
   - **3回以上なら: STOP。アーキテクチャを疑う（下の手順5）**
   - Fix #4 を試す前に構造議論を行うこと

5. **3回以上失敗したらアーキテクチャを疑う**

   **アーキテクチャ問題の兆候:**
   - 各修正が別の場所の共有状態/結合/問題を露呈する
   - 修正に「大規模なリファクタリング」が必要になる
   - 修正のたびに別の症状が出る

   **STOPして根本を疑う:**
   - このパターン自体が健全か？
   - 惰性で続けていないか？
   - 症状修正を続けるべきか、アーキテクチャを見直すべきか？

   **さらなる修正を試す前に人間のパートナーと議論する**

   これは仮説の失敗ではなく、アーキテクチャの誤りである。

## レッドフラグ - STOPしてプロセスに戻る

次のように考えているなら:
- 「今だけの簡単修正、後で調べる」
- 「とりあえずXを変えてみる」
- 「複数変更を入れてテストを回す」
- 「テストを飛ばして手で確認する」
- 「多分Xだろうから直す」
- 「完全には分からないけど動きそう」
- 「パターンはXと言うが、別の形にしてみる」
- 「主な問題はこれです:（調査なしの修正一覧）」
- データフロー追跡前に解決策を提案している
- **「もう1回だけ修正」(すでに2回以上試した後)**
- **修正のたびに別の場所で新しい問題が出る**

**これらはすべて: STOP。Phase 1 に戻る。**

**3回以上失敗したら:** アーキテクチャを疑う（Phase 4.5 参照）

## 人間パートナーからの「やり方が間違っている」サイン

**次のように言われたら注意:**
- 「それ、本当に起きてる？」 - 検証せずに決めつけた
- 「それって確認できる？」 - 証拠収集が必要
- 「推測しないで」 - 理解せずに修正案を出している
- 「もっと根本から考えて」 - 症状ではなく土台を疑うべき
- 「詰まってる？」（苛立ち） - アプローチが機能していない

**こう言われたら:** STOP。Phase 1 に戻る。

## よくある正当化

| 言い訳 | 現実 |
|--------|------|
| 「簡単な問題だから手順はいらない」 | 簡単な問題にも根本原因はある。手順は簡単なバグほど速い。 |
| 「緊急だから手順に時間を割けない」 | 系統立てたデバッグの方が当てずっぽうより速い。 |
| 「まず試してから調べる」 | 最初の修正が流れを決める。最初から正しくやる。 |
| 「動くのを確認してからテストを書く」 | テストなしの修正は定着しない。先にテストで証明する。 |
| 「一度に複数直せば早い」 | 何が効いたか分からない。新しいバグを生む。 |
| 「参照が長いから雰囲気で合わせる」 | 部分的理解はバグを保証する。最後まで読む。 |
| 「問題が見えたから直す」 | 症状の可視化 ≠ 根本原因の理解。 |
| 「もう1回だけ修正」(2回以上失敗後) | 3回以上の失敗 = アーキテクチャ問題。再修正ではなくパターンを疑う。 |

## クイックリファレンス

| フェーズ | 主な活動 | 成功基準 |
|---------|---------|---------|
| **1. 根本原因** | エラーを読む、再現、変更確認、証拠収集 | WHAT と WHY を理解 |
| **2. パターン** | 動く例を探す、比較 | 差分を特定 |
| **3. 仮説** | 仮説を立て、最小検証 | 確認済み or 新しい仮説 |
| **4. 実装** | テスト作成、修正、検証 | バグ解決、テスト合格 |

## 「根本原因がない」と判明したとき

系統立てた調査の結果、問題が環境要因・タイミング依存・外部要因だと分かった場合:

1. すべての手順を完了している
2. 何を調べたかを記録する
3. 適切な対処（リトライ、タイムアウト、エラーメッセージ）を実装する
4. 将来の調査に向けて監視/ログを追加する

**ただし:** 「根本原因がない」ケースの95%は調査不足。

## 支援テクニック

これらは系統立てたデバッグの一部として、このディレクトリにある:

- **`root-cause-tracing.md`** - コールスタックを逆に辿って元のトリガーを見つける
- **`defense-in-depth.md`** - 根本原因を見つけた後に多層バリデーションを追加する
- **`condition-based-waiting.md`** - 任意の待機時間を条件ポーリングに置き換える

**関連スキル:**
- **superpowers:test-driven-development** - 失敗テストケースを作る（Phase 4, Step 1）
- **superpowers:verification-before-completion** - 修正が効いたことを宣言前に確認する

## 実運用での効果

デバッグセッションの実例:
- 系統立てたアプローチ: 15-30分で解決
- 当てずっぽう: 2-3時間の迷走
- 初回での修正成功率: 95% vs 40%
- 新規バグの混入: ほぼゼロ vs よく起きる
